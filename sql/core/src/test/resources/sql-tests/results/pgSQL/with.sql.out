-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 121


-- !query 0
WITH q1(x,y) AS (SELECT 1,2)
SELECT * FROM q1, q1 AS q2
-- !query 0 schema
struct<x:int,y:int,x:int,y:int>
-- !query 0 output
1	2	1	2


-- !query 1
SELECT count(*) FROM (
  WITH q1(x) AS (SELECT rand() FROM (SELECT EXPLODE(SEQUENCE(1, 5))))
    SELECT * FROM q1
  UNION
    SELECT * FROM q1
) ss
-- !query 1 schema
struct<count(1):bigint>
-- !query 1 output
10


-- !query 2
WITH RECURSIVE t(n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
-- !query 2 schema
struct<sum(n):bigint>
-- !query 2 output
5050


-- !query 3
WITH RECURSIVE t(n) AS (
    SELECT (VALUES(1))
UNION ALL
    SELECT n+1 FROM t WHERE n < 5
)
SELECT * FROM t
-- !query 3 schema
struct<n:int>
-- !query 3 output
1
2
3
4
5


-- !query 4
CREATE TEMPORARY VIEW nums AS
WITH RECURSIVE nums (n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums WHERE n < 5
)
SELECT * FROM nums
-- !query 4 schema
struct<>
-- !query 4 output



-- !query 5
SELECT * FROM nums
-- !query 5 schema
struct<n:int>
-- !query 5 output
1
2
3
4
5


-- !query 6
CREATE OR REPLACE TEMPORARY VIEW nums AS
WITH RECURSIVE nums (n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums WHERE n < 6
)
SELECT * FROM nums
-- !query 6 schema
struct<>
-- !query 6 output



-- !query 7
SELECT * FROM nums
-- !query 7 schema
struct<n:int>
-- !query 7 output
1
2
3
4
5
6


-- !query 8
WITH RECURSIVE t(n) AS (
    SELECT 1
UNION
    SELECT 10-n FROM t)
SELECT * FROM t
-- !query 8 schema
struct<n:int>
-- !query 8 output
1
9


-- !query 9
WITH RECURSIVE t(n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM t)
SELECT * FROM t LIMIT 10
-- !query 9 schema
struct<n:int>
-- !query 9 output
1
10
2
3
4
5
6
7
8
9


-- !query 10
WITH RECURSIVE t(n) AS (
    SELECT 1
UNION
    SELECT n+1 FROM t)
SELECT * FROM t LIMIT 10
-- !query 10 schema
struct<n:int>
-- !query 10 output
1
10
2
3
4
5
6
7
8
9


-- !query 11
WITH q AS (SELECT 'foo' AS x)
SELECT x FROM q
-- !query 11 schema
struct<x:string>
-- !query 11 output
foo


-- !query 12
WITH RECURSIVE t(n) AS (
    SELECT 'foo'
UNION ALL
    SELECT n || ' bar' FROM t WHERE length(n) < 20
)
SELECT n AS is_text FROM t
-- !query 12 schema
struct<is_text:string>
-- !query 12 output
foo
foo bar
foo bar bar
foo bar bar bar
foo bar bar bar bar
foo bar bar bar bar bar


-- !query 13
WITH RECURSIVE t(n) AS (
    SELECT '7'
UNION ALL
    SELECT n+1 FROM t WHERE n < 10
)
SELECT n FROM t
-- !query 13 schema
struct<>
-- !query 13 output
org.apache.spark.sql.AnalysisException
Recursive table t term types List(StringType) and List(DoubleType) do not match;


-- !query 14
CREATE TABLE department (
	id INTEGER,  -- department ID
	parent_department INTEGER, -- upper department ID
	name string -- department name
) USING parquet
-- !query 14 schema
struct<>
-- !query 14 output



-- !query 15
INSERT INTO department VALUES (0, NULL, 'ROOT')
-- !query 15 schema
struct<>
-- !query 15 output



-- !query 16
INSERT INTO department VALUES (1, 0, 'A')
-- !query 16 schema
struct<>
-- !query 16 output



-- !query 17
INSERT INTO department VALUES (2, 1, 'B')
-- !query 17 schema
struct<>
-- !query 17 output



-- !query 18
INSERT INTO department VALUES (3, 2, 'C')
-- !query 18 schema
struct<>
-- !query 18 output



-- !query 19
INSERT INTO department VALUES (4, 2, 'D')
-- !query 19 schema
struct<>
-- !query 19 output



-- !query 20
INSERT INTO department VALUES (5, 0, 'E')
-- !query 20 schema
struct<>
-- !query 20 output



-- !query 21
INSERT INTO department VALUES (6, 4, 'F')
-- !query 21 schema
struct<>
-- !query 21 output



-- !query 22
INSERT INTO department VALUES (7, 5, 'G')
-- !query 22 schema
struct<>
-- !query 22 output



-- !query 23
WITH RECURSIVE subdepartment AS
(
	-- non recursive term
	SELECT name as root_name, * FROM department WHERE name = 'A'

	UNION ALL

	-- recursive term
	SELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd
		WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query 23 schema
struct<root_name:string,id:int,parent_department:int,name:string>
-- !query 23 output
A	1	0	A
A	2	1	B
A	3	2	C
A	4	2	D
A	6	4	F


-- !query 24
WITH RECURSIVE subdepartment(level, id, parent_department, name) AS
(
	-- non recursive term
	SELECT 1, * FROM department WHERE name = 'A'

	UNION ALL

	-- recursive term
	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd
		WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment ORDER BY name
-- !query 24 schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query 24 output
1	1	0	A
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query 25
WITH RECURSIVE subdepartment(level, id, parent_department, name) AS
(
	-- non recursive term
	SELECT 1, * FROM department WHERE name = 'A'

	UNION ALL

	-- recursive term
	SELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd
		WHERE d.parent_department = sd.id
)
SELECT * FROM subdepartment WHERE level >= 2 ORDER BY name
-- !query 25 schema
struct<level:int,id:int,parent_department:int,name:string>
-- !query 25 output
2	2	1	B
3	3	2	C
3	4	2	D
4	6	4	F


-- !query 26
WITH RECURSIVE subdepartment AS
(
	-- note lack of recursive UNION structure
	SELECT * FROM department WHERE name = 'A'
)
SELECT * FROM subdepartment ORDER BY name
-- !query 26 schema
struct<id:int,parent_department:int,name:string>
-- !query 26 output
1	0	A


-- !query 27
SET spark.sql.cte.recursion.level.limit=500
-- !query 27 schema
struct<key:string,value:string>
-- !query 27 output
spark.sql.cte.recursion.level.limit	500


-- !query 28
SELECT count(*) FROM (
    WITH RECURSIVE t(n) AS (
        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500
    )
    SELECT * FROM t) AS t WHERE n < (
        SELECT count(*) FROM (
            WITH RECURSIVE t(n) AS (
                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100
                )
            SELECT * FROM t WHERE n < 50000
         ) AS t WHERE n < 100)
-- !query 28 schema
struct<count(1):bigint>
-- !query 28 output
98


-- !query 29
SET spark.sql.cte.recursion.level.limit=100
-- !query 29 schema
struct<key:string,value:string>
-- !query 29 output
spark.sql.cte.recursion.level.limit	100


-- !query 30
WITH q1(x,y) AS (
    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred
  )
SELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub)
-- !query 30 schema
struct<count(1):bigint>
-- !query 30 output
50


-- !query 31
CREATE VIEW vsubdepartment AS
	WITH RECURSIVE subdepartment AS
	(
		 -- non recursive term
		SELECT * FROM department WHERE name = 'A'
		UNION ALL
		-- recursive term
		SELECT d.* FROM department AS d, subdepartment AS sd
			WHERE d.parent_department = sd.id
	)
	SELECT * FROM subdepartment
-- !query 31 schema
struct<>
-- !query 31 output



-- !query 32
SELECT * FROM vsubdepartment ORDER BY name
-- !query 32 schema
struct<id:int,parent_department:int,name:string>
-- !query 32 output
1	0	A
2	1	B
3	2	C
4	2	D
6	4	F


-- !query 33
SHOW CREATE TABLE vsubdepartment
-- !query 33 schema
struct<createtab_stmt:string>
-- !query 33 output
CREATE VIEW `vsubdepartment`(id, parent_department, name) AS
WITH RECURSIVE subdepartment AS
	(
		 -- non recursive term
		SELECT * FROM department WHERE name = 'A'
		UNION ALL
		-- recursive term
		SELECT d.* FROM department AS d, subdepartment AS sd
			WHERE d.parent_department = sd.id
	)
	SELECT * FROM subdepartment


-- !query 34
DROP VIEW vsubdepartment
-- !query 34 schema
struct<>
-- !query 34 output



-- !query 35
CREATE VIEW sums_1_100 AS
WITH RECURSIVE t(n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t
-- !query 35 schema
struct<>
-- !query 35 output



-- !query 36
SHOW CREATE TABLE sums_1_100
-- !query 36 schema
struct<createtab_stmt:string>
-- !query 36 output
CREATE VIEW `sums_1_100`(sum(n)) AS
WITH RECURSIVE t(n) AS (
    VALUES (1)
UNION ALL
    SELECT n+1 FROM t WHERE n < 100
)
SELECT sum(n) FROM t


-- !query 37
DROP VIEW sums_1_100
-- !query 37 schema
struct<>
-- !query 37 output



-- !query 38
<<<<<<< HEAD
create table foo (with ordinality)
=======
with recursive q as (
      select * from department
    union all
      (with x as (select * from q)
       select * from x)
    )
select * from q limit 24
>>>>>>> [SPARK-24497][SQL] Support recursive SQL query
-- !query 38 schema
struct<id:int,parent_department:int,name:string>
-- !query 38 output
<<<<<<< HEAD
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'with'(line 1, pos 18)

== SQL ==
create table foo (with ordinality)
------------------^^^


-- !query 39
with ordinality as (select 1 as x) select * from ordinality
=======
0	NULL	ROOT
0	NULL	ROOT
0	NULL	ROOT
1	0	A
1	0	A
1	0	A
2	1	B
2	1	B
2	1	B
3	2	C
3	2	C
3	2	C
4	2	D
4	2	D
4	2	D
5	0	E
5	0	E
5	0	E
6	4	F
6	4	F
6	4	F
7	5	G
7	5	G
7	5	G


-- !query 39
with recursive q as (
      select * from department
    union all
      (with recursive x as (
           select * from department
         union all
           (select * from q union all select * from x)
        )
       select * from x)
    )
select * from q limit 32
>>>>>>> [SPARK-24497][SQL] Support recursive SQL query
-- !query 39 schema
struct<id:int,parent_department:int,name:string>
-- !query 39 output
0	NULL	ROOT
0	NULL	ROOT
0	NULL	ROOT
0	NULL	ROOT
1	0	A
1	0	A
1	0	A
1	0	A
2	1	B
2	1	B
2	1	B
2	1	B
3	2	C
3	2	C
3	2	C
3	2	C
4	2	D
4	2	D
4	2	D
4	2	D
5	0	E
5	0	E
5	0	E
5	0	E
6	4	F
6	4	F
6	4	F
6	4	F
7	5	G
7	5	G
7	5	G
7	5	G


-- !query 40
WITH RECURSIVE t(i,j) AS (
	VALUES (1,2)
	UNION ALL
	SELECT t2.i, t.j+1 FROM
		(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2
		JOIN t ON (t2.i = t.i+1))

	SELECT * FROM t
-- !query 40 schema
struct<i:int,j:int>
-- !query 40 output
1	2
2	3
3	4


-- !query 41
CREATE TABLE tree(
    id INTEGER,
    parent_id INTEGER
) USING parquet
-- !query 41 schema
struct<>
-- !query 41 output



-- !query 42
INSERT INTO tree
VALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),
       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11)
-- !query 42 schema
struct<>
-- !query 42 output



-- !query 43
WITH RECURSIVE t(id, path) AS (
    VALUES(1,cast(array() as array<Int>))
UNION ALL
    SELECT tree.id, t.path || array(tree.id)
    FROM tree JOIN t ON (tree.parent_id = t.id)
)
SELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON
	(t1.path[0] = t2.path[0] AND
	size(t1.path) = 1 AND
	size(t2.path) > 1)
	ORDER BY t1.id, t2.id
-- !query 43 schema
struct<id:int,path:array<int>,id:int,path:array<int>>
-- !query 43 output
2	[2]	4	[2,4]
2	[2]	5	[2,5]
2	[2]	6	[2,6]
2	[2]	9	[2,4,9]
2	[2]	10	[2,4,10]
2	[2]	14	[2,4,9,14]
3	[3]	7	[3,7]
3	[3]	8	[3,8]
3	[3]	11	[3,7,11]
3	[3]	12	[3,7,12]
3	[3]	13	[3,7,13]
3	[3]	15	[3,7,11,15]
3	[3]	16	[3,7,11,16]


-- !query 44
WITH RECURSIVE t(id, path) AS (
    VALUES(1,cast(array() as array<Int>))
UNION ALL
    SELECT tree.id, t.path || array(tree.id)
    FROM tree JOIN t ON (tree.parent_id = t.id)
)
SELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON
	(t1.path[0] = t2.path[0] AND
	size(t1.path) = 1 AND
	size(t2.path) > 1)
	GROUP BY t1.id
	ORDER BY t1.id
-- !query 44 schema
struct<id:int,count(id, path):bigint>
-- !query 44 output
2	6
3	7


-- !query 45
WITH RECURSIVE t(id, path) AS (
    VALUES(1,cast(array() as array<Int>))
UNION ALL
    SELECT tree.id, t.path || array(tree.id)
    FROM tree JOIN t ON (tree.parent_id = t.id)
)
SELECT t1.id, t2.path, struct(t2.*) FROM t AS t1 JOIN t AS t2 ON
(t1.id=t2.id)
-- !query 45 schema
struct<id:int,path:array<int>,named_struct(id, id, path, path):struct<id:int,path:array<int>>>
-- !query 45 output
1	[]	{"id":1,"path":[]}
10	[2,4,10]	{"id":10,"path":[2,4,10]}
11	[3,7,11]	{"id":11,"path":[3,7,11]}
12	[3,7,12]	{"id":12,"path":[3,7,12]}
13	[3,7,13]	{"id":13,"path":[3,7,13]}
14	[2,4,9,14]	{"id":14,"path":[2,4,9,14]}
15	[3,7,11,15]	{"id":15,"path":[3,7,11,15]}
16	[3,7,11,16]	{"id":16,"path":[3,7,11,16]}
2	[2]	{"id":2,"path":[2]}
3	[3]	{"id":3,"path":[3]}
4	[2,4]	{"id":4,"path":[2,4]}
5	[2,5]	{"id":5,"path":[2,5]}
6	[2,6]	{"id":6,"path":[2,6]}
7	[3,7]	{"id":7,"path":[3,7]}
8	[3,8]	{"id":8,"path":[3,8]}
9	[2,4,9]	{"id":9,"path":[2,4,9]}


-- !query 46
create table graph( f int, t int, label string ) USING parquet
-- !query 46 schema
struct<>
-- !query 46 output



-- !query 47
insert into graph values
	(1, 2, 'arc 1 -> 2'),
	(1, 3, 'arc 1 -> 3'),
	(2, 3, 'arc 2 -> 3'),
	(1, 4, 'arc 1 -> 4'),
	(4, 5, 'arc 4 -> 5'),
	(5, 1, 'arc 5 -> 1')
-- !query 47 schema
struct<>
-- !query 47 output



-- !query 48
with recursive search_graph(f, t, label, path, cycle) as (
	select *, array(struct(g.f, g.t)), false from graph g
	union all
	select g.*, path || array(struct(g.f, g.t)), array_contains(path, struct(g.f, g.t))
	from graph g, search_graph sg
	where g.f = sg.t and not cycle
)
select * from search_graph
-- !query 48 schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query 48 output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false


-- !query 49
with recursive search_graph(f, t, label, path, cycle) as (
	select *, array(struct(g.f, g.t)), false from graph g
	union all
	select g.*, path || array(struct(g.f, g.t)), array_contains(path, struct(g.f, g.t))
	from graph g, search_graph sg
	where g.f = sg.t and not cycle
)
select * from search_graph order by path
-- !query 49 schema
struct<f:int,t:int,label:string,path:array<struct<f:int,t:int>>,cycle:boolean>
-- !query 49 output
1	2	arc 1 -> 2	[{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	true
2	3	arc 2 -> 3	[{"f":2,"t":3}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":4,"t":5},{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":4,"t":5},{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	true
5	1	arc 5 -> 1	[{"f":5,"t":1}]	false
1	2	arc 1 -> 2	[{"f":5,"t":1},{"f":1,"t":2}]	false
2	3	arc 2 -> 3	[{"f":5,"t":1},{"f":1,"t":2},{"f":2,"t":3}]	false
1	3	arc 1 -> 3	[{"f":5,"t":1},{"f":1,"t":3}]	false
1	4	arc 1 -> 4	[{"f":5,"t":1},{"f":1,"t":4}]	false
4	5	arc 4 -> 5	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5}]	false
5	1	arc 5 -> 1	[{"f":5,"t":1},{"f":1,"t":4},{"f":4,"t":5},{"f":5,"t":1}]	true


-- !query 50
WITH RECURSIVE
  y (id) AS (VALUES (1)),
  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)
SELECT * FROM x
-- !query 50 schema
struct<id:int>
-- !query 50 output
1
2
3
4
5


-- !query 51
WITH RECURSIVE
    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),
    y(id) AS (values (1))
 SELECT * FROM x
-- !query 51 schema
struct<>
-- !query 51 output
org.apache.spark.sql.AnalysisException
Table or view not found: y; line 2 pos 28


-- !query 52
WITH RECURSIVE
   x(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
   y(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)
 SELECT y.*, x.* FROM y LEFT JOIN x ON x.id = y.id
-- !query 52 schema
struct<id:int,id:int>
-- !query 52 output
1	1
10	NULL
2	2
3	3
4	4
5	5
6	NULL
7	NULL
8	NULL
9	NULL


-- !query 53
WITH RECURSIVE
   x(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),
   y(id) AS
     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)
 SELECT y.*, x.* FROM y LEFT JOIN x ON x.id = y.id
-- !query 53 schema
struct<id:int,id:int>
-- !query 53 output
1	1
2	2
3	3
4	4
5	5
6	NULL


-- !query 54
WITH RECURSIVE
   x(id) AS
     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
   y(id) AS
     (SELECT * FROM x UNION ALL SELECT * FROM x),
   z(id) AS
     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)
 SELECT * FROM z
-- !query 54 schema
struct<id:int>
-- !query 54 output
1
10
10
10
2
2
3
3
3
4
4
4
5
5
5
6
6
6
7
7
7
8
8
8
9
9
9


-- !query 55
WITH RECURSIVE
   x(id) AS
     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),
   y(id) AS
     (SELECT * FROM x UNION ALL SELECT * FROM x),
   z(id) AS
     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)
 SELECT * FROM z
-- !query 55 schema
struct<id:int>
-- !query 55 output
1
1
10
10
10
10
10
10
2
2
2
2
3
3
3
3
3
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
8
8
8
8
8
8
9
9
9
9
9
9


-- !query 56
CREATE TABLE y (a INTEGER) USING parquet
-- !query 56 schema
struct<>
-- !query 56 output



-- !query 57
INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10))
-- !query 57 schema
struct<>
-- !query 57 output



-- !query 58
DROP TABLE y
-- !query 58 schema
struct<>
-- !query 58 output



-- !query 59
WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)
	SELECT * FROM x
-- !query 59 schema
struct<>
-- !query 59 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 60
WITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)
	SELECT * FROM x
-- !query 60 schema
struct<>
-- !query 60 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 61
WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)
	SELECT * FROM x
-- !query 61 schema
struct<>
-- !query 61 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 62
WITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)
	SELECT * FROM x
-- !query 62 schema
struct<>
-- !query 62 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 63
WITH RECURSIVE x(n) AS (SELECT n FROM x)
	SELECT * FROM x
-- !query 63 schema
struct<>
-- !query 63 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 64
WITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)
	SELECT * FROM x
-- !query 64 schema
struct<>
-- !query 64 output
org.apache.spark.SparkException
Recursion level limit 100 reached but query has not exhausted, try increasing spark.sql.cte.recursion.level.limit


-- !query 65
CREATE TABLE y (a INTEGER) USING parquet
-- !query 65 schema
struct<>
-- !query 65 output



-- !query 66
INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 10))
-- !query 66 schema
struct<>
-- !query 66 output



-- !query 67
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
	UNION ALL
	SELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)
SELECT * FROM x
-- !query 67 schema
struct<>
-- !query 67 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 68
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
	UNION ALL
	SELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)
SELECT * FROM x
-- !query 68 schema
struct<>
-- !query 68 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 69
WITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1
	UNION ALL
	SELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)
SELECT * FROM x
-- !query 69 schema
struct<>
-- !query 69 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 70
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x
                          WHERE n IN (SELECT * FROM x))
  SELECT * FROM x
-- !query 70 schema
struct<>
-- !query 70 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 71
WITH RECURSIVE x(n) AS (SELECT 1L UNION ALL SELECT count(*) FROM x)
  SELECT * FROM x
-- !query 71 schema
struct<>
-- !query 71 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 72
WITH RECURSIVE x(n) AS (SELECT 1L UNION ALL SELECT sum(n) FROM x)
  SELECT * FROM x
-- !query 72 schema
struct<>
-- !query 72 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 73
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)
  SELECT * FROM x
-- !query 73 schema
struct<>
-- !query 73 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 74
WITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10)
  SELECT * FROM x
-- !query 74 schema
struct<>
-- !query 74 output
org.apache.spark.sql.AnalysisException
Recursive query x should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 75
WITH RECURSIVE x(id) AS (values (1)
    UNION ALL
    SELECT (SELECT * FROM x) FROM x WHERE id < 5
) SELECT * FROM x
-- !query 75 schema
struct<>
-- !query 75 output
org.apache.spark.sql.AnalysisException
Recursive reference x cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 76
WITH RECURSIVE
  x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),
  y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)
SELECT * FROM x
-- !query 76 schema
struct<>
-- !query 76 output
org.apache.spark.sql.AnalysisException
cannot resolve '`id`' given input columns: [default.y.a]; line 2 pos 57


-- !query 77
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
       (SELECT i+1 FROM foo WHERE i < 10
          UNION ALL
       SELECT i+1 FROM foo WHERE i < 5)
) SELECT * FROM foo
-- !query 77 schema
struct<i:int>
-- !query 77 output
1
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
3
4
4
4
4
4
4
4
4
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9


-- !query 78
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
	   SELECT * FROM
       (SELECT i+1 FROM foo WHERE i < 10
          UNION ALL
       SELECT i+1 FROM foo WHERE i < 5) AS t
) SELECT * FROM foo
-- !query 78 schema
struct<i:int>
-- !query 78 output
1
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
3
4
4
4
4
4
4
4
4
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
5
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
6
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9
9


-- !query 79
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
       (SELECT i+1 FROM foo WHERE i < 10
          EXCEPT
       SELECT i+1 FROM foo WHERE i < 5)
) SELECT * FROM foo
-- !query 79 schema
struct<>
-- !query 79 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 80
WITH RECURSIVE foo(i) AS
    (values (1)
    UNION ALL
       (SELECT i+1 FROM foo WHERE i < 10
          INTERSECT
       SELECT i+1 FROM foo WHERE i < 5)
) SELECT * FROM foo
-- !query 80 schema
struct<>
-- !query 80 output
org.apache.spark.sql.AnalysisException
Recursive reference foo cannot be used multiple times in a recursive term;


-- !query 81
WITH RECURSIVE foo(i) AS
   (SELECT i FROM (VALUES(1),(2)) t(i)
   UNION ALL
   SELECT cast((i+1) AS decimal(10,0)) FROM foo WHERE i < 10)
SELECT * FROM foo
-- !query 81 schema
struct<>
-- !query 81 output
org.apache.spark.sql.AnalysisException
Recursive table foo term types List(IntegerType) and List(DecimalType(10,0)) do not match;


-- !query 82
WITH RECURSIVE foo(i) AS
   (SELECT cast(i as decimal(3,0)) FROM (VALUES(1),(2)) t(i)
   UNION ALL
   SELECT cast((i+1) AS decimal(10,0)) FROM foo WHERE i < 10)
SELECT * FROM foo
-- !query 82 schema
struct<>
-- !query 82 output
org.apache.spark.sql.AnalysisException
Recursive table foo term types List(DecimalType(3,0)) and List(DecimalType(10,0)) do not match;


-- !query 83
with cte(foo) as ( select 42 ) select * from ((select foo from cte)) q
-- !query 83 schema
struct<foo:int>
-- !query 83 output
42


-- !query 84
WITH RECURSIVE t(j) AS (
    WITH RECURSIVE s(i) AS (
        VALUES (1)
        UNION ALL
        SELECT i+1 FROM s WHERE i < 10
    )
    SELECT i FROM s
    UNION ALL
    SELECT j+1 FROM t WHERE j < 10
)
SELECT * FROM t
-- !query 84 schema
struct<j:int>
-- !query 84 output
1
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
4
4
4
4
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9


-- !query 85
WITH outermost(x) AS (
  SELECT 1
  UNION (WITH innermost as (SELECT 2)
         SELECT * FROM innermost
         UNION SELECT 3)
)
SELECT * FROM outermost ORDER BY 1
-- !query 85 schema
struct<x:int>
-- !query 85 output
1
2
3


-- !query 86
WITH outermost(x) AS (
  SELECT 1
  UNION (WITH innermost as (SELECT 2)
         SELECT * FROM outermost  -- fail
         UNION SELECT * FROM innermost)
)
SELECT * FROM outermost ORDER BY 1
-- !query 86 schema
struct<>
-- !query 86 output
org.apache.spark.sql.AnalysisException
Table or view not found: outermost; line 4 pos 23


-- !query 87
WITH RECURSIVE outermost(x) AS (
  SELECT 1
  UNION (WITH innermost as (SELECT 2)
         SELECT * FROM outermost
         UNION SELECT * FROM innermost)
)
SELECT * FROM outermost ORDER BY 1
-- !query 87 schema
struct<x:int>
-- !query 87 output
1
2


-- !query 88
WITH RECURSIVE outermost(x) AS (
  WITH innermost as (SELECT 2 FROM outermost) -- fail
    SELECT * FROM innermost
    UNION SELECT * from outermost
)
SELECT * FROM outermost ORDER BY 1
-- !query 88 schema
struct<>
-- !query 88 output
org.apache.spark.sql.AnalysisException
There should be at least one anchor term defined in the recursive query outermost;


-- !query 89
WITH RECURSIVE
  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
  iter (id_key, row_type, link) AS (
      SELECT 0, 'base', 17
    UNION ALL (
      WITH remaining(id_key, row_type, link, min) AS (
        SELECT tab.id_key, 'true', iter.link, MIN(tab.id_key) OVER ()
        FROM tab INNER JOIN iter ON iter.link=tab.link
        WHERE tab.id_key > iter.id_key
      ),
      first_remaining AS (
        SELECT id_key, row_type, link
        FROM remaining
        WHERE id_key=min
      ),
      effect AS (
        SELECT tab.id_key, 'new', tab.link
        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
        WHERE e.row_type = 'false'
      )
      SELECT * FROM first_remaining
      UNION ALL SELECT * FROM effect
    )
  )
SELECT * FROM iter
-- !query 89 schema
struct<id_key:int,row_type:string,link:int>
-- !query 89 output
0	base	17
1	true	17
2	true	17
3	true	17
4	true	17
5	true	17
6	true	17


-- !query 90
WITH RECURSIVE
  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),
  iter (id_key, row_type, link) AS (
      SELECT 0, 'base', 17
    UNION (
      WITH remaining(id_key, row_type, link, min) AS (
        SELECT tab.id_key, 'true', iter.link, MIN(tab.id_key) OVER ()
        FROM tab INNER JOIN iter ON iter.link=tab.link
        WHERE tab.id_key > iter.id_key
      ),
      first_remaining AS (
        SELECT id_key, row_type, link
        FROM remaining
        WHERE id_key=min
      ),
      effect AS (
        SELECT tab.id_key, 'new', tab.link
        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key
        WHERE e.row_type = 'false'
      )
      SELECT * FROM first_remaining
      UNION ALL SELECT * FROM effect
    )
  )
SELECT * FROM iter
-- !query 90 schema
struct<id_key:int,row_type:string,link:int>
-- !query 90 output
0	base	17
1	true	17
2	true	17
3	true	17
4	true	17
5	true	17
6	true	17


-- !query 91
CREATE TABLE withz USING parquet AS SELECT i AS k, CAST(i || ' v' AS string) v FROM (SELECT EXPLODE(SEQUENCE(1, 16, 3)) i)
-- !query 91 schema
struct<>
-- !query 91 output



-- !query 92
SELECT * FROM withz ORDER BY k
-- !query 92 schema
struct<k:int,v:string>
-- !query 92 output
1	1 v
4	4 v
7	7 v
10	10 v
13	13 v
16	16 v


-- !query 93
DROP TABLE withz
-- !query 93 schema
struct<>
-- !query 93 output



-- !query 94
TRUNCATE TABLE y
-- !query 94 schema
struct<>
-- !query 94 output



-- !query 95
INSERT INTO y SELECT EXPLODE(SEQUENCE(1, 3))
-- !query 95 schema
struct<>
-- !query 95 output



-- !query 96
CREATE TABLE yy (a INTEGER) USING parquet
-- !query 96 schema
struct<>
-- !query 96 output



-- !query 97
SELECT * FROM y
-- !query 97 schema
struct<a:int>
-- !query 97 output
1
2
3


-- !query 98
SELECT * FROM yy
-- !query 98 schema
struct<a:int>
-- !query 98 output



-- !query 99
SELECT * FROM y
-- !query 99 schema
struct<a:int>
-- !query 99 output
1
2
3


-- !query 100
SELECT * FROM yy
-- !query 100 schema
struct<a:int>
-- !query 100 output



-- !query 101
CREATE TABLE parent ( id int, val string ) USING parquet
-- !query 101 schema
struct<>
-- !query 101 output



-- !query 102
INSERT INTO parent VALUES ( 1, 'p1' )
-- !query 102 schema
struct<>
-- !query 102 output



-- !query 103
SELECT * FROM parent
-- !query 103 schema
struct<id:int,val:string>
-- !query 103 output
1	p1


-- !query 104
SELECT * FROM parent
-- !query 104 schema
struct<id:int,val:string>
-- !query 104 output
1	p1


-- !query 105
WITH RECURSIVE t AS (
	INSERT INTO y
		SELECT * FROM t
)
VALUES(FALSE)
-- !query 105 schema
struct<>
-- !query 105 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH RECURSIVE t AS (\n\tINSERT'(line 2, pos 1)

== SQL ==
WITH RECURSIVE t AS (
	INSERT INTO y
-^^^
		SELECT * FROM t
)
VALUES(FALSE)


-- !query 106
WITH t AS (
	INSERT INTO y VALUES(0)
)
SELECT * FROM t
-- !query 106 schema
struct<>
-- !query 106 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH t AS (\n\tINSERT'(line 2, pos 1)

== SQL ==
WITH t AS (
	INSERT INTO y VALUES(0)
-^^^
)
SELECT * FROM t


-- !query 107
create table foo (with baz)
-- !query 107 schema
struct<>
-- !query 107 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'with'(line 1, pos 18)

== SQL ==
create table foo (with baz)
------------------^^^


-- !query 108
-- fail, WITH is a reserved word
create table foo (with ordinality)
-- !query 108 schema
struct<>
-- !query 108 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'with'(line 2, pos 18)

== SQL ==
-- fail, WITH is a reserved word
create table foo (with ordinality)
------------------^^^


-- !query 109
-- fail, WITH is a reserved word
with ordinality as (select 1 as x) select * from ordinality
-- !query 109 schema
struct<x:int>
-- !query 109 output
1


-- !query 110
WITH test AS (SELECT 42) INSERT INTO test VALUES (1)
-- !query 110 schema
struct<>
-- !query 110 output
org.apache.spark.sql.AnalysisException
Table not found: test;


-- !query 111
create table test (i int) USING parquet
-- !query 111 schema
struct<>
-- !query 111 output



-- !query 112
with test as (select 42) insert into test select * from test
-- !query 112 schema
struct<>
-- !query 112 output



-- !query 113
select * from test
-- !query 113 schema
struct<i:int>
-- !query 113 output
42


-- !query 114
drop table test
-- !query 114 schema
struct<>
-- !query 114 output



-- !query 115
DROP TABLE department
-- !query 115 schema
struct<>
-- !query 115 output



-- !query 116
DROP TABLE tree
-- !query 116 schema
struct<>
-- !query 116 output



-- !query 117
DROP TABLE graph
-- !query 117 schema
struct<>
-- !query 117 output



-- !query 118
DROP TABLE y
-- !query 118 schema
struct<>
-- !query 118 output



-- !query 119
DROP TABLE yy
-- !query 119 schema
struct<>
-- !query 119 output



-- !query 120
DROP TABLE parent
-- !query 120 schema
struct<>
-- !query 120 output

