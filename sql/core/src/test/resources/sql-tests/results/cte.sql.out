-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 63


-- !query 0
create temporary view t as select * from values 0, 1, 2 as t(id)
-- !query 0 schema
struct<>
-- !query 0 output



-- !query 1
create temporary view t2 as select * from values 0, 1 as t(id)
-- !query 1 schema
struct<>
-- !query 1 output



-- !query 2
WITH s AS (SELECT 1 FROM s) SELECT * FROM s
-- !query 2 schema
struct<>
-- !query 2 output
org.apache.spark.sql.AnalysisException
Table or view not found: s; line 1 pos 25


-- !query 3
WITH r AS (SELECT (SELECT * FROM r))
SELECT * FROM r
-- !query 3 schema
struct<>
-- !query 3 output
org.apache.spark.sql.AnalysisException
Table or view not found: r; line 1 pos 33


-- !query 4
WITH t AS (SELECT 1 FROM t) SELECT * FROM t
-- !query 4 schema
struct<1:int>
-- !query 4 output
1
1
1


-- !query 5
WITH s1 AS (SELECT 1 FROM s2), s2 AS (SELECT 1 FROM s1) SELECT * FROM s1, s2
-- !query 5 schema
struct<>
-- !query 5 output
org.apache.spark.sql.AnalysisException
Table or view not found: s2; line 1 pos 26


-- !query 6
WITH t1 AS (SELECT * FROM t2), t2 AS (SELECT 2 FROM t1) SELECT * FROM t1 cross join t2
-- !query 6 schema
struct<id:int,2:int>
-- !query 6 output
0	2
0	2
1	2
1	2


-- !query 7
WITH CTE1 AS (
  SELECT b.id AS id
  FROM   T2 a
         CROSS JOIN (SELECT id AS id FROM T2) b
)
SELECT t1.id AS c1,
       t2.id AS c2
FROM   CTE1 t1
       CROSS JOIN CTE1 t2
-- !query 7 schema
struct<c1:int,c2:int>
-- !query 7 output
0	0
0	0
0	0
0	0
0	1
0	1
0	1
0	1
1	0
1	0
1	0
1	0
1	1
1	1
1	1
1	1


-- !query 8
WITH t(x) AS (SELECT 1)
SELECT * FROM t WHERE x = 1
-- !query 8 schema
struct<x:int>
-- !query 8 output
1


-- !query 9
WITH t(x, y) AS (SELECT 1, 2)
SELECT * FROM t WHERE x = 1 AND y = 2
-- !query 9 schema
struct<x:int,y:int>
-- !query 9 output
1	2


-- !query 10
WITH t(x, x) AS (SELECT 1, 2)
SELECT * FROM t
-- !query 10 schema
struct<x:int,x:int>
-- !query 10 output
1	2


-- !query 11
WITH t() AS (SELECT 1)
SELECT * FROM t
-- !query 11 schema
struct<>
-- !query 11 output
org.apache.spark.sql.catalyst.parser.ParseException

no viable alternative at input 'WITH t()'(line 1, pos 7)

== SQL ==
WITH t() AS (SELECT 1)
-------^^^
SELECT * FROM t


-- !query 12
WITH
  t(x) AS (SELECT 1),
  t(x) AS (SELECT 2)
SELECT * FROM t
-- !query 12 schema
struct<>
-- !query 12 output
org.apache.spark.sql.catalyst.parser.ParseException

CTE definition can't have duplicate names: 't'.(line 1, pos 0)

== SQL ==
WITH
^^^
  t(x) AS (SELECT 1),
  t(x) AS (SELECT 2)
SELECT * FROM t


-- !query 13
WITH t as (
  WITH t2 AS (SELECT 1)
  SELECT * FROM t2
)
SELECT * FROM t
-- !query 13 schema
struct<1:int>
-- !query 13 output
1


-- !query 14
SELECT max(c) FROM (
  WITH t(c) AS (SELECT 1)
  SELECT * FROM t
)
-- !query 14 schema
struct<max(c):int>
-- !query 14 output
1


-- !query 15
SELECT (
  WITH t AS (SELECT 1)
  SELECT * FROM t
)
-- !query 15 schema
struct<scalarsubquery():int>
-- !query 15 output
1


-- !query 16
WITH
  t AS (SELECT 1),
  t2 AS (
    WITH t AS (SELECT 2)
    SELECT * FROM t
  )
SELECT * FROM t2
-- !query 16 schema
struct<2:int>
-- !query 16 output
2


-- !query 17
WITH
  t(c) AS (SELECT 1),
  t2 AS (
    SELECT (
      SELECT max(c) FROM (
        WITH t(c) AS (SELECT 2)
        SELECT * FROM t
      )
    )
  )
SELECT * FROM t2
-- !query 17 schema
struct<scalarsubquery():int>
-- !query 17 output
2


-- !query 18
WITH
  t AS (SELECT 1),
  t2 AS (
    WITH t AS (SELECT 2),
    t2 AS (
      WITH t AS (SELECT 3)
      SELECT * FROM t
    )
    SELECT * FROM t2
  )
SELECT * FROM t2
-- !query 18 schema
struct<3:int>
-- !query 18 output
3


-- !query 19
WITH t(c) AS (SELECT 1)
SELECT max(c) FROM (
  WITH t(c) AS (SELECT 2)
  SELECT * FROM t
)
-- !query 19 schema
struct<max(c):int>
-- !query 19 output
2


-- !query 20
WITH t(c) AS (SELECT 1)
SELECT sum(c) FROM (
  SELECT max(c) AS c FROM (
    WITH t(c) AS (SELECT 2)
    SELECT * FROM t
  )
)
-- !query 20 schema
struct<sum(c):bigint>
-- !query 20 output
2


-- !query 21
WITH t(c) AS (SELECT 1)
SELECT sum(c) FROM (
  WITH t(c) AS (SELECT 2)
  SELECT max(c) AS c FROM (
    WITH t(c) AS (SELECT 3)
    SELECT * FROM t
  )
)
-- !query 21 schema
struct<sum(c):bigint>
-- !query 21 output
3


-- !query 22
WITH t AS (SELECT 1)
SELECT (
  WITH t AS (SELECT 2)
  SELECT * FROM t
)
-- !query 22 schema
struct<scalarsubquery():int>
-- !query 22 output
2


-- !query 23
WITH t AS (SELECT 1)
SELECT (
  SELECT (
    WITH t AS (SELECT 2)
    SELECT * FROM t
  )
)
-- !query 23 schema
struct<scalarsubquery():int>
-- !query 23 output
2


-- !query 24
WITH t AS (SELECT 1)
SELECT (
  WITH t AS (SELECT 2)
  SELECT (
    WITH t AS (SELECT 3)
    SELECT * FROM t
  )
)
-- !query 24 schema
struct<scalarsubquery():int>
-- !query 24 output
3


-- !query 25
WITH r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 25 schema
struct<>
-- !query 25 output
org.apache.spark.sql.AnalysisException
Table or view not found: r; line 4 pos 24


-- !query 26
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 26 schema
struct<level:int>
-- !query 26 output
0
1
10
2
3
4
5
6
7
8
9


-- !query 27
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r
-- !query 27 schema
struct<>
-- !query 27 output
org.apache.spark.SparkException
Recursion level limit 100 reached but query has not exhausted, try increasing spark.sql.cte.recursion.level.limit


-- !query 28
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT * FROM r LIMIT 10
-- !query 28 schema
struct<level:int>
-- !query 28 output
0
1
2
3
4
5
6
7
8
9


-- !query 29
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT level, level FROM r LIMIT 10
-- !query 29 schema
struct<level:int,level:int>
-- !query 29 output
0	0
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9


-- !query 30
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r
)
SELECT level, level FROM r ORDER BY level LIMIT 10
-- !query 30 schema
struct<>
-- !query 30 output
org.apache.spark.SparkException
Recursion level limit 100 reached but query has not exhausted, try increasing spark.sql.cte.recursion.level.limit


-- !query 31
WITH RECURSIVE r(c) AS (
  SELECT 'a'
  UNION ALL
  SELECT c || ' b' FROM r WHERE LENGTH(c) < 10
)
SELECT * FROM r
-- !query 31 schema
struct<c:string>
-- !query 31 output
a
a b
a b b
a b b b
a b b b b
a b b b b b


-- !query 32
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 10
  UNION ALL
  VALUES (0)
)
SELECT * FROM r
-- !query 32 schema
struct<level:int>
-- !query 32 output
0
1
10
2
3
4
5
6
7
8
9


-- !query 33
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  VALUES (0, 'B')
  UNION ALL
  SELECT level + 1, data || 'C' FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 33 schema
struct<level:int,data:string>
-- !query 33 output
0	A
0	B
1	AC
1	BC
2	ACC
2	BCC
3	ACCC
3	BCCC


-- !query 34
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, data || 'B' FROM r WHERE level < 2
  UNION ALL
  SELECT level + 1, data || 'C' FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 34 schema
struct<level:int,data:string>
-- !query 34 output
0	A
1	AB
1	AC
2	ABB
2	ABC
2	ACB
2	ACC
3	ABBC
3	ABCC
3	ACBC
3	ACCC


-- !query 35
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  VALUES (0, 'B')
  UNION ALL
  SELECT level + 1, data || 'C' FROM r WHERE level < 2
  UNION ALL
  SELECT level + 1, data || 'D' FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 35 schema
struct<level:int,data:string>
-- !query 35 output
0	A
0	B
1	AC
1	AD
1	BC
1	BD
2	ACC
2	ACD
2	ADC
2	ADD
2	BCC
2	BCD
2	BDC
2	BDD
3	ACCD
3	ACDD
3	ADCD
3	ADDD
3	BCCD
3	BCDD
3	BDCD
3	BDDD


-- !query 36
WITH RECURSIVE r(level) AS (
  SELECT level + 1 FROM r WHERE level < 3
)
SELECT * FROM r
-- !query 36 schema
struct<>
-- !query 36 output
org.apache.spark.sql.AnalysisException
Recursive query r should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 37
WITH RECURSIVE r(level) AS (
  VALUES (0), (0)
  UNION
  SELECT (level + 1) % 10 FROM r
)
SELECT * FROM r
-- !query 37 schema
struct<level:int>
-- !query 37 output
0
1
2
3
4
5
6
7
8
9


-- !query 38
WITH RECURSIVE r(level) AS (
  VALUES (0)
  INTERSECT
  SELECT level + 1 FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 38 schema
struct<>
-- !query 38 output
org.apache.spark.sql.AnalysisException
Recursive query r should contain UNION or UNION ALL statements only. This error can also be caused by ORDER BY or LIMIT keywords used on result of UNION or UNION ALL.;


-- !query 39
WITH RECURSIVE r(level) AS (
  VALUES (0)
  UNION ALL
  SELECT level + 1 FROM r WHERE (SELECT SUM(level) FROM r) < 10
)
SELECT * FROM r
-- !query 39 schema
struct<>
-- !query 39 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 40
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT r1.level + 1, r1.data
  FROM r AS r1
  JOIN r AS r2 ON r2.data = r1.data
  WHERE r1.level < 10
)
SELECT * FROM r
-- !query 40 schema
struct<>
-- !query 40 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used multiple times in a recursive term;


-- !query 41
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, r.data
  FROM (
    SELECT 'B' AS data
  ) AS o
  LEFT JOIN r ON r.data = o.data
)
SELECT * FROM r
-- !query 41 schema
struct<>
-- !query 41 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 42
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, r.data
  FROM r
  RIGHT JOIN (
    SELECT 'B' AS data
  ) AS o ON o.data = r.data
)
SELECT * FROM r
-- !query 42 schema
struct<>
-- !query 42 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 43
WITH RECURSIVE r(level, data) AS (
  SELECT MAX(level) AS level, SUM(data) AS data FROM VALUES (0, 1), (0, 2)
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r ORDER BY level
-- !query 43 schema
struct<>
-- !query 43 output
org.apache.spark.sql.AnalysisException
cannot resolve '`level`' given input columns: [col1, col2]; line 2 pos 13


-- !query 44
WITH RECURSIVE r(group, data) AS (
  VALUES (0, 1L)
  UNION ALL
  SELECT 1, SUM(data) FROM r WHERE data < 10 GROUP BY group
)
SELECT * FROM r
-- !query 44 schema
struct<>
-- !query 44 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 45
WITH RECURSIVE r(level) AS (
  VALUES (1L)
  UNION ALL
  SELECT SUM(level) FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 45 schema
struct<>
-- !query 45 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 46
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT level + 1, data FROM r WHERE level < 10
)
SELECT COUNT(*) FROM r
-- !query 46 schema
struct<count(1):bigint>
-- !query 46 output
11


-- !query 47
WITH RECURSIVE r(level, data) AS (
  VALUES (0, 'A')
  UNION ALL
  SELECT DISTINCT level + 1, data FROM r WHERE level < 10
)
SELECT * FROM r
-- !query 47 schema
struct<>
-- !query 47 output
org.apache.spark.sql.AnalysisException
Recursive reference r cannot be used here. This can be caused by using it on inner side of an outer join, using it with aggregate or distinct, using it in a subquery or using it multiple times in a recursive term (except for using it on different sides of an UNION ALL).;


-- !query 48
WITH RECURSIVE y AS (
  VALUES (1) AS t(id)
),
x AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
)
SELECT * FROM x
-- !query 48 schema
struct<id:int>
-- !query 48 output
1
2
3
4
5


-- !query 49
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM y WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 49 schema
struct<id:int,id:int>
-- !query 49 output
1	1
10	NULL
2	2
3	3
4	4
5	5
6	NULL
7	NULL
8	NULL
9	NULL


-- !query 50
WITH RECURSIVE x AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 5
),
y AS (
  VALUES (1) AS t(id)
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 10
)
SELECT * FROM y LEFT JOIN x ON x.id = y.id
-- !query 50 schema
struct<id:int,id:int>
-- !query 50 output
1	1
2	2
3	3
4	4
5	5
6	NULL


-- !query 51
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM x
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 51 schema
struct<id:int>
-- !query 51 output
1
10
10
10
2
2
3
3
3
4
4
4
5
5
5
6
6
6
7
7
7
8
8
8
9
9
9


-- !query 52
WITH RECURSIVE x AS (
  SELECT 1 AS id
  UNION ALL
  SELECT id + 1 FROM x WHERE id < 3
),
y AS (
  SELECT * FROM x
  UNION ALL
  SELECT * FROM x
),
z AS (
  SELECT * FROM y
  UNION ALL
  SELECT id + 1 FROM z WHERE id < 10
)
SELECT * FROM z
-- !query 52 schema
struct<id:int>
-- !query 52 output
1
1
10
10
10
10
10
10
2
2
2
2
3
3
3
3
3
3
4
4
4
4
4
4
5
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
8
8
8
8
8
8
9
9
9
9
9
9


-- !query 53
WITH t AS (
  WITH RECURSIVE s AS (
    VALUES (1) AS t(i)
    UNION ALL
    SELECT i + 1 FROM s
  )
  SELECT i AS j FROM s LIMIT 10
)
SELECT * FROM t
-- !query 53 schema
struct<j:int>
-- !query 53 output
1
10
2
3
4
5
6
7
8
9


-- !query 54
WITH RECURSIVE outermost AS (
  WITH innermost AS (
    SELECT * FROM outermost
  )
  SELECT level + 1 FROM innermost WHERE level < 5
  UNION ALL
  SELECT 0 AS level
)
SELECT * FROM outermost
-- !query 54 schema
struct<level:int>
-- !query 54 output
0
1
2
3
4
5


-- !query 55
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
    VALUES (1) AS t(i)
    UNION ALL
    SELECT i + 1 FROM s WHERE i < 10
  )
  SELECT i AS j FROM s
  UNION ALL
  SELECT j + 1 FROM t WHERE j < 10
)
SELECT * FROM t
-- !query 55 schema
struct<j:int>
-- !query 55 output
1
10
10
10
10
10
10
10
10
10
10
2
2
3
3
3
4
4
4
4
5
5
5
5
5
6
6
6
6
6
6
7
7
7
7
7
7
7
8
8
8
8
8
8
8
8
9
9
9
9
9
9
9
9
9


-- !query 56
WITH RECURSIVE t AS (
  WITH RECURSIVE s AS (
    SELECT j, 1 AS i FROM t
    UNION ALL
    SELECT j, i + 1 FROM s WHERE i < 3
  )
  VALUES (1) as t(j)
  UNION ALL
  SELECT j + 1 FROM s WHERE j < 3
)
SELECT * FROM t
-- !query 56 schema
struct<j:int>
-- !query 56 output
1
2
2
2
3
3
3
3
3
3
3
3
3


-- !query 57
CREATE TEMPORARY VIEW routes(origin, destination) AS VALUES
  ('New York', 'Washington'),
  ('New York', 'Boston'),
  ('Boston', 'New York'),
  ('Washington', 'Boston'),
  ('Washington', 'Raleigh')
-- !query 57 schema
struct<>
-- !query 57 output



-- !query 58
WITH RECURSIVE destinations_from_new_york AS (
  SELECT 'New York' AS destination, ARRAY('New York') AS path, 0 AS length
  UNION ALL
  SELECT r.destination, CONCAT(d.path, ARRAY(r.destination)), d.length + 1
  FROM routes AS r
  JOIN destinations_from_new_york AS d ON d.destination = r.origin AND NOT ARRAY_CONTAINS(d.path, r.destination)
)
SELECT * FROM destinations_from_new_york
-- !query 58 schema
struct<destination:string,path:array<string>,length:int>
-- !query 58 output
Boston	["New York","Boston"]	1
Boston	["New York","Washington","Boston"]	2
New York	["New York"]	0
Raleigh	["New York","Washington","Raleigh"]	2
Washington	["New York","Washington"]	1


-- !query 59
WITH RECURSIVE fibonacci AS (
  VALUES (0, 1) AS t(a, b)
  UNION ALL
  SELECT b, a + b FROM fibonacci WHERE a < 10
)
SELECT a FROM fibonacci ORDER BY a
-- !query 59 schema
struct<a:int>
-- !query 59 output
0
1
1
2
3
5
8
13


-- !query 60
WITH RECURSIVE sudoku AS (
  VALUES (
    ARRAY(
      0, 0, 6, 0, 2, 3, 0, 0, 1,
      5, 0, 0, 0, 0, 0, 9, 0, 0,
      0, 0, 2, 0, 0, 4, 0, 0, 0,
      2, 0, 0, 8, 0, 0, 0, 9, 3,
      0, 0, 1, 0, 0, 7, 0, 0, 0,
      8, 3, 0, 0, 0, 0, 4, 0, 0,
      6, 0, 0, 1, 0, 0, 5, 0, 4,
      0, 5, 0, 0, 0, 0, 6, 0, 0,
      0, 0, 9, 0, 7, 0, 0, 2, 0
    ),
    0
  ) AS t(puzzle, level)
  UNION ALL
  SELECT
    CONCAT(SLICE(puzzle, 1, newPosition - 1), ARRAY(newValue), SLICE(puzzle, newPosition + 1, 9 * 9 - newPosition)),
    level + 1
  FROM (
    SELECT
      puzzle,
      newPosition,
      EXPLODE(allowedValues) AS newValue,
      level
    FROM (
      SELECT
        puzzle,
        newPosition,
        ARRAY_EXCEPT(
          ARRAY_EXCEPT(
            ARRAY_EXCEPT(
              SEQUENCE(1, 9),
              -- used values in row
              SLICE(puzzle, FLOOR((newPosition - 1) / 9) * 9 + 1, 9)
            ),
            -- used values in column
            TRANSFORM(puzzle, (x, i) -> IF(i % 9 = (newPosition - 1) % 9, x, 0))
          ),
          -- used values in 3x3 block
          TRANSFORM(
            SLICE(puzzle, FLOOR((newPosition - 1) / (3 * 9)) * 3 * 9 + 1, 3 * 9),
            (x, i) -> IF(FLOOR(i / 3) % 3 = FLOOR((newPosition - 1) / 3) % 3, x, 0)
          )
        ) AS allowedValues,
        level
      FROM sudoku
      JOIN (SELECT EXPLODE(SEQUENCE(1, 9 * 9)) AS newPosition) ON puzzle[newPosition - 1] = 0
      ORDER BY SIZE(allowedValues)
      LIMIT 1
    )
  )
)
SELECT * FROM sudoku WHERE NOT ARRAY_CONTAINS(puzzle, 0)
-- !query 60 schema
struct<puzzle:array<int>,level:int>
-- !query 60 output
[4,8,6,9,2,3,7,5,1,5,1,3,7,6,8,9,4,2,7,9,2,5,1,4,8,3,6,2,7,4,8,5,6,1,9,3,9,6,1,3,4,7,2,8,5,8,3,5,2,9,1,4,6,7,6,2,8,1,3,9,5,7,4,3,5,7,4,8,2,6,1,9,1,4,9,6,7,5,3,2,8]	55


-- !query 61
DROP VIEW IF EXISTS t
-- !query 61 schema
struct<>
-- !query 61 output



-- !query 62
DROP VIEW IF EXISTS t2
-- !query 62 schema
struct<>
-- !query 62 output

