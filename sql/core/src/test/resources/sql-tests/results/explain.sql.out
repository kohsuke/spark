-- Automatically generated by SQLQueryTestSuite
-- Number of queries: 19


-- !query 0
CREATE table  explain_temp1 (key int, val int) USING PARQUET
-- !query 0 schema
struct<>
-- !query 0 output



-- !query 1
CREATE table  explain_temp2 (key int, val int) USING PARQUET
-- !query 1 schema
struct<>
-- !query 1 output



-- !query 2
CREATE table  explain_temp3 (key int, val int) USING PARQUET
-- !query 2 schema
struct<>
-- !query 2 output



-- !query 3
SET spark.sql.explain.legacy.format = false
-- !query 3 schema
struct<key:string,value:string>
-- !query 3 output
spark.sql.explain.legacy.format	false


-- !query 4
SET spark.sql.codegen.wholeStage = true
-- !query 4 schema
struct<key:string,value:string>
-- !query 4 output
spark.sql.codegen.wholeStage	true


-- !query 5
EXPLAIN
  SELECT KEY, Max(val) 
  FROM   explain_temp1 
  WHERE  KEY > 0 
  GROUP  BY KEY 
  ORDER  BY KEY
-- !query 5 schema
struct<plan:string>
-- !query 5 output
== Physical Plan ==
Sort (8)
+- Exchange (7)
   +- HashAggregate (6)
      +- Exchange (5)
         +- HashAggregate (4)
            +- Project (3)
               +- Filter (2)
                  +- Scan parquet default.explain_temp1 (1)


(1) Scan parquet default.explain_temp1 [codegen id : 1]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (isnotnull(KEY#x) AND (KEY#x > 0))
     
(3) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(4) HashAggregate [codegen id : 1]
Input: [key#x, val#x]
     
(5) Exchange 
Input: [KEY#x, max#x]
     
(6) HashAggregate [codegen id : 2]
Input: [KEY#x, max#x]
     
(7) Exchange 
Input: [KEY#x, max(val)#x]
     
(8) Sort [codegen id : 3]
Input: [KEY#x, max(val)#x]


-- !query 6
EXPLAIN
  SELECT key, Max(val)
  FROM explain_temp1
  WHERE key > 0
  GROUP BY key
  HAVING max(val) > 0
-- !query 6 schema
struct<plan:string>
-- !query 6 output
== Physical Plan ==
Project (8)
+- Filter (7)
   +- HashAggregate (6)
      +- Exchange (5)
         +- HashAggregate (4)
            +- Project (3)
               +- Filter (2)
                  +- Scan parquet default.explain_temp1 (1)


(1) Scan parquet default.explain_temp1 [codegen id : 1]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 0))
     
(3) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(4) HashAggregate [codegen id : 1]
Input: [key#x, val#x]
     
(5) Exchange 
Input: [key#x, max#x]
     
(6) HashAggregate [codegen id : 2]
Input: [key#x, max#x]
     
(7) Filter [codegen id : 2]
Input     : [key#x, max(val)#x, max(val#x)#x]
Condition : (isnotnull(max(val#x)#x) AND (max(val#x)#x > 0))
     
(8) Project [codegen id : 2]
Output    : [key#x, max(val)#x]
Input     : [key#x, max(val)#x, max(val#x)#x]


-- !query 7
EXPLAIN
  SELECT key, val FROM explain_temp1 WHERE key > 0
  UNION 
  SELECT key, val FROM explain_temp1 WHERE key > 0
-- !query 7 schema
struct<plan:string>
-- !query 7 output
== Physical Plan ==
HashAggregate (7)
+- Exchange (6)
   +- HashAggregate (5)
      +- Union (4)
         :- Project (3)
         :  +- Filter (2)
         :     +- Scan parquet default.explain_temp1 (1)
         +- Project (3)
            +- Filter (2)
               +- Scan parquet default.explain_temp1 (1)


(1) Scan parquet default.explain_temp1 [codegen id : 2]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 2]
Input     : [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 0))
     
(3) Project [codegen id : 2]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(4) Union 
     
(5) HashAggregate [codegen id : 3]
Input: [key#x, val#x]
     
(6) Exchange 
Input: [key#x, val#x]
     
(7) HashAggregate [codegen id : 4]
Input: [key#x, val#x]


-- !query 8
EXPLAIN
  SELECT * 
  FROM   explain_temp1 a, 
         explain_temp2 b 
  WHERE  a.KEY = b.KEY
-- !query 8 schema
struct<plan:string>
-- !query 8 output
== Physical Plan ==
BroadcastHashJoin Inner BuildRight (8)
:- Project (3)
:  +- Filter (2)
:     +- Scan parquet default.explain_temp1 (1)
+- BroadcastExchange (7)
   +- Project (6)
      +- Filter (5)
         +- Scan parquet default.explain_temp2 (4)


(1) Scan parquet default.explain_temp1 [codegen id : 2]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 2]
Input     : [key#x, val#x]
Condition : isnotnull(KEY#x)
     
(3) Project [codegen id : 2]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(4) Scan parquet default.explain_temp2 [codegen id : 1]
Output: [key#x, val#x]
     
(5) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : isnotnull(KEY#x)
     
(6) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(7) BroadcastExchange 
Input: [key#x, val#x]
     
(8) BroadcastHashJoin [codegen id : 2]
Left keys: List(KEY#x)
Right keys: List(KEY#x)
Join condition: None


-- !query 9
EXPLAIN
  SELECT * 
  FROM   explain_temp1 a 
         INNER JOIN explain_temp2 b 
                 ON a.KEY = b.KEY
-- !query 9 schema
struct<plan:string>
-- !query 9 output
== Physical Plan ==
BroadcastHashJoin Inner BuildRight (8)
:- Project (3)
:  +- Filter (2)
:     +- Scan parquet default.explain_temp1 (1)
+- BroadcastExchange (7)
   +- Project (6)
      +- Filter (5)
         +- Scan parquet default.explain_temp2 (4)


(1) Scan parquet default.explain_temp1 [codegen id : 2]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 2]
Input     : [key#x, val#x]
Condition : isnotnull(KEY#x)
     
(3) Project [codegen id : 2]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(4) Scan parquet default.explain_temp2 [codegen id : 1]
Output: [key#x, val#x]
     
(5) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : isnotnull(KEY#x)
     
(6) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(7) BroadcastExchange 
Input: [key#x, val#x]
     
(8) BroadcastHashJoin [codegen id : 2]
Left keys: List(KEY#x)
Right keys: List(KEY#x)
Join condition: None


-- !query 10
EXPLAIN
  SELECT * 
  FROM   explain_temp1 a 
         LEFT OUTER JOIN explain_temp2 b 
                      ON a.KEY = b.KEY
-- !query 10 schema
struct<plan:string>
-- !query 10 output
== Physical Plan ==
BroadcastHashJoin LeftOuter BuildRight (6)
:- Scan parquet default.explain_temp1 (1)
+- BroadcastExchange (5)
   +- Project (4)
      +- Filter (3)
         +- Scan parquet default.explain_temp2 (2)


(1) Scan parquet default.explain_temp1 [codegen id : 2]
Output: [key#x, val#x]
     
(2) Scan parquet default.explain_temp2 [codegen id : 1]
Output: [key#x, val#x]
     
(3) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : isnotnull(KEY#x)
     
(4) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(5) BroadcastExchange 
Input: [key#x, val#x]
     
(6) BroadcastHashJoin [codegen id : 2]
Left keys: List(KEY#x)
Right keys: List(KEY#x)
Join condition: None


-- !query 11
EXPLAIN
  SELECT * 
  FROM   explain_temp1 
  WHERE  KEY = (SELECT Max(KEY) 
                FROM   explain_temp2 
                WHERE  KEY = (SELECT Max(KEY) 
                              FROM   explain_temp3 
                              WHERE  val > 0) 
                       AND val = 2) 
         AND val > 3
-- !query 11 schema
struct<plan:string>
-- !query 11 output
== Physical Plan ==
Project (3)
+- Filter (2)
   +- Scan parquet default.explain_temp1 (1)


(1) Scan parquet default.explain_temp1 [codegen id : 1]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (((isnotnull(KEY#x) AND isnotnull(val#x)) AND (KEY#x = Subquery subquery#x)) AND (val#x > 3))
     
(3) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
===== Subqueries =====

Subquery:1 Hosting operator id = 2 Hosting Expression = Subquery subquery#x
HashAggregate (9)
+- Exchange (8)
   +- HashAggregate (7)
      +- Project (6)
         +- Filter (5)
            +- Scan parquet default.explain_temp2 (4)


(4) Scan parquet default.explain_temp2 [codegen id : 1]
Output: [key#x, val#x]
     
(5) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (((isnotnull(KEY#x) AND isnotnull(val#x)) AND (KEY#x = Subquery subquery#x)) AND (val#x = 2))
     
(6) Project [codegen id : 1]
Output    : [key#x]
Input     : [key#x, val#x]
     
(7) HashAggregate [codegen id : 1]
Input: [key#x]
     
(8) Exchange 
Input: [max#x]
     
(9) HashAggregate [codegen id : 2]
Input: [max#x]
     
Subquery:2 Hosting operator id = 5 Hosting Expression = Subquery subquery#x
HashAggregate (15)
+- Exchange (14)
   +- HashAggregate (13)
      +- Project (12)
         +- Filter (11)
            +- Scan parquet default.explain_temp3 (10)


(10) Scan parquet default.explain_temp3 [codegen id : 1]
Output: [key#x, val#x]
     
(11) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (isnotnull(val#x) AND (val#x > 0))
     
(12) Project [codegen id : 1]
Output    : [key#x]
Input     : [key#x, val#x]
     
(13) HashAggregate [codegen id : 1]
Input: [key#x]
     
(14) Exchange 
Input: [max#x]
     
(15) HashAggregate [codegen id : 2]
Input: [max#x]


-- !query 12
EXPLAIN
  SELECT * 
  FROM   explain_temp1 
  WHERE  KEY = (SELECT Max(KEY) 
                FROM   explain_temp2 
                WHERE  val > 0) 
         OR
         KEY = (SELECT Max(KEY) 
                FROM   explain_temp3
                WHERE  val > 0)
-- !query 12 schema
struct<plan:string>
-- !query 12 output
== Physical Plan ==
Filter (2)
+- Scan parquet default.explain_temp1 (1)


(1) Scan parquet default.explain_temp1 [codegen id : 1]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : ((KEY#x = Subquery subquery#x) OR (KEY#x = Subquery subquery#x))
     
===== Subqueries =====

Subquery:1 Hosting operator id = 2 Hosting Expression = Subquery subquery#x
HashAggregate (8)
+- Exchange (7)
   +- HashAggregate (6)
      +- Project (5)
         +- Filter (4)
            +- Scan parquet default.explain_temp2 (3)


(3) Scan parquet default.explain_temp2 [codegen id : 1]
Output: [key#x, val#x]
     
(4) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (isnotnull(val#x) AND (val#x > 0))
     
(5) Project [codegen id : 1]
Output    : [key#x]
Input     : [key#x, val#x]
     
(6) HashAggregate [codegen id : 1]
Input: [key#x]
     
(7) Exchange 
Input: [max#x]
     
(8) HashAggregate [codegen id : 2]
Input: [max#x]
     
Subquery:2 Hosting operator id = 2 Hosting Expression = Subquery subquery#x
HashAggregate (14)
+- Exchange (13)
   +- HashAggregate (12)
      +- Project (11)
         +- Filter (10)
            +- Scan parquet default.explain_temp3 (9)


(9) Scan parquet default.explain_temp3 [codegen id : 1]
Output: [key#x, val#x]
     
(10) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (isnotnull(val#x) AND (val#x > 0))
     
(11) Project [codegen id : 1]
Output    : [key#x]
Input     : [key#x, val#x]
     
(12) HashAggregate [codegen id : 1]
Input: [key#x]
     
(13) Exchange 
Input: [max#x]
     
(14) HashAggregate [codegen id : 2]
Input: [max#x]


-- !query 13
EXPLAIN
  SELECT (SELECT Avg(key) FROM explain_temp1) + (SELECT Avg(key) FROM explain_temp1)
  FROM explain_temp1
-- !query 13 schema
struct<plan:string>
-- !query 13 output
== Physical Plan ==
Project (2)
+- Scan parquet default.explain_temp1 (1)


(1) Scan parquet default.explain_temp1 [codegen id : 1]
Output: []
     
(2) Project [codegen id : 1]
Output    : [(Subquery subquery#x + ReusedSubquery Subquery subquery#x) AS (scalarsubquery() + scalarsubquery())#x]
Input     : []
     
===== Subqueries =====

Subquery:1 Hosting operator id = 2 Hosting Expression = Subquery subquery#x
HashAggregate (6)
+- Exchange (5)
   +- HashAggregate (4)
      +- Scan parquet default.explain_temp1 (3)


(3) Scan parquet default.explain_temp1 [codegen id : 1]
Output: [key#x]
     
(4) HashAggregate [codegen id : 1]
Input: [key#x]
     
(5) Exchange 
Input: [sum#x, count#xL]
     
(6) HashAggregate [codegen id : 2]
Input: [sum#x, count#xL]
     
Subquery:2 Hosting operator id = 2 Hosting Expression = ReusedSubquery Subquery subquery#x


-- !query 14
EXPLAIN
  WITH cte1 AS (
    SELECT *
    FROM explain_temp1 
    WHERE key > 10
  )
  SELECT * FROM cte1 a, cte1 b WHERE a.key = b.key
-- !query 14 schema
struct<plan:string>
-- !query 14 output
== Physical Plan ==
BroadcastHashJoin Inner BuildRight (8)
:- Project (3)
:  +- Filter (2)
:     +- Scan parquet default.explain_temp1 (1)
+- BroadcastExchange (7)
   +- Project (6)
      +- Filter (5)
         +- Scan parquet default.explain_temp1 (4)


(1) Scan parquet default.explain_temp1 [codegen id : 2]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 2]
Input     : [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 10))
     
(3) Project [codegen id : 2]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(4) Scan parquet default.explain_temp1 [codegen id : 1]
Output: [key#x, val#x]
     
(5) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 10))
     
(6) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(7) BroadcastExchange 
Input: [key#x, val#x]
     
(8) BroadcastHashJoin [codegen id : 2]
Left keys: List(key#x)
Right keys: List(key#x)
Join condition: None


-- !query 15
EXPLAIN
  WITH cte1 AS (
    SELECT key, max(val)
    FROM explain_temp1 
    WHERE key > 10
    GROUP BY key
  )
  SELECT * FROM cte1 a, cte1 b WHERE a.key = b.key
-- !query 15 schema
struct<plan:string>
-- !query 15 output
== Physical Plan ==
BroadcastHashJoin Inner BuildRight (10)
:- HashAggregate (6)
:  +- Exchange (5)
:     +- HashAggregate (4)
:        +- Project (3)
:           +- Filter (2)
:              +- Scan parquet default.explain_temp1 (1)
+- BroadcastExchange (9)
   +- HashAggregate (8)
      +- ReusedExchange (7)


(1) Scan parquet default.explain_temp1 [codegen id : 1]
Output: [key#x, val#x]
     
(2) Filter [codegen id : 1]
Input     : [key#x, val#x]
Condition : (isnotnull(key#x) AND (key#x > 10))
     
(3) Project [codegen id : 1]
Output    : [key#x, val#x]
Input     : [key#x, val#x]
     
(4) HashAggregate [codegen id : 1]
Input: [key#x, val#x]
     
(5) Exchange 
Input: [key#x, max#x]
     
(6) HashAggregate [codegen id : 4]
Input: [key#x, max#x]
     
(7) ReusedExchange  [Reuses operator id: 5]
Output : ArrayBuffer(key#x, max#x)
     
(8) HashAggregate [codegen id : 3]
Input: [key#x, max#x]
     
(9) BroadcastExchange 
Input: [key#x, max(val)#x]
     
(10) BroadcastHashJoin [codegen id : 4]
Left keys: List(key#x)
Right keys: List(key#x)
Join condition: None


-- !query 16
DROP TABLE explain_temp1
-- !query 16 schema
struct<>
-- !query 16 output



-- !query 17
DROP TABLE explain_temp2
-- !query 17 schema
struct<>
-- !query 17 output



-- !query 18
DROP TABLE explain_temp3
-- !query 18 schema
struct<>
-- !query 18 output

